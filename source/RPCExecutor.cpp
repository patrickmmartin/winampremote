/*
 * RPCServer.cpp
 *
 *  Created on: 4 Nov 2012
 *      Author: Patrick
 */


#include "RPCExecutor.h"
#include "RPCErrors.h"

// problem with definition of __try - this gets round out with no problems
#define __try try

#include "winampinterface.h"    // header file generated by MIDL compiler

// winamp interface
#include "waint.h"

//RPC errors
#include "RPCErrors.h"

#include "RPCExecutor.h"

#include <sstream>

using namespace std;


static void * __stdcall MIDL_user_allocate(size_t size)
{
	return malloc(size);
}

namespace WinampRemote
{
namespace Server
{

RPCExecutor::RPCExecutor() : m_callObserver(), m_winamp(),
							 m_protocolSequence("ncacn_np"),
							 m_endPoint("\\pipe\\winampremote"),
							 m_executionStatus(waInactive)
{

}

RPCExecutor::~RPCExecutor()
{
	// as Execute blocks, given destruction happens on the same thread
	// no need to ensure shutdown was happened
}

std::string RPCExecutor::getProtocolSequence() const
{
	return m_protocolSequence;
}

void RPCExecutor::setProtocolSequence(const std::string value)
{
	m_protocolSequence = value;
}

std::string RPCExecutor::getEndpoint() const
{
	return m_protocolSequence;
}

void RPCExecutor::setEndpoint(const std::string value)
{
	m_protocolSequence = value;
}

RPCExecutor& RPCExecutor::instance()
{
	static RPCExecutor instance;

	return instance;
}

WinampRemote::Server::IWinampServer * RPCExecutor::getWinampServer() const
{
	return m_winamp;
}


void RPCExecutor::setWinampServer(WinampRemote::Server::IWinampServer * const winampServer)
{
	m_winamp = winampServer;
}

WinampRemote::Remoting::ICallObserver * RPCExecutor::getCallObserver() const
{
	return m_callObserver;
}

void RPCExecutor::setCallObserver(WinampRemote::Remoting::ICallObserver * const callObserver)
{
	m_callObserver = callObserver;
}

void RPCExecutor::Execute()
{
	// tempting to throw an exception here
	if (!m_callObserver)
	{
		setExecutionStatus(waInitialiseFailed);
		return;
	}
	if (!m_winamp)
	{
		m_callObserver->notifyException("winamp implementation is not set");
		setExecutionStatus(waInitialiseFailed);
		return;
	}

	std::string str;
    RPC_STATUS status;
    // "ncacn_np" for named pip
    // "ncacn_ip_tcp" for tcpip

    m_callObserver->notifyStatus("initialising...");

    m_callObserver->notifyMessage(m_winamp->WinampVersion().c_str());

	setExecutionStatus(waServerStarting);
    status = RpcServerUseProtseqEp((unsigned char *) m_protocolSequence.c_str(),
                                   20,
                                   (unsigned char *) m_endPoint.c_str(),
                                   NULL);

    if (status == RPC_S_OK){
      status = RpcServerRegisterIf(winamp_v1_0_s_ifspec, NULL, NULL);
      if (status == RPC_S_OK){
    	  m_callObserver->notifyMessage("listening...");
  		setExecutionStatus(waListening);
        status = RpcServerListen(1, 20, FALSE);
        if (status != RPC_S_OK){
      		setExecutionStatus(waInitialiseFailed);
        	m_callObserver->notifyException("error in listening");
        	m_callObserver->notifyException(RPCError(status));
          }
        }
    else{
  		setExecutionStatus(waInitialiseFailed);
    	m_callObserver->notifyException("failed to register interface");
    	m_callObserver->notifyException(RPCError(status));
    	m_callObserver->notifyException("initialise failed");
      }
    }
  else{
	  setExecutionStatus(waInitialiseFailed);
	  m_callObserver->notifyException("failed to create protocol sequence");
	  m_callObserver->notifyException(RPCError(status));
	  m_callObserver->notifyException("initialise failed");
  }
  setExecutionStatus(waServerStopped);

}

void RPCExecutor::setExecutionStatus(WAExecutionStatus status)
{
	m_executionStatus = status;
}

WAExecutionStatus RPCExecutor::getExecutionStatus()
{
	return m_executionStatus;
}


} /* namespace Server */
} /* namespace WinampRemote */


static void inline MainMessage(const char * msgString)
{
	WinampRemote::Server::RPCExecutor::instance().getCallObserver()->notifyMessage(msgString);
}

static void inline MainStatus(const char * msgString)
{
	WinampRemote::Server::RPCExecutor::instance().getCallObserver()->notifyStatus(msgString);
}

static WinampRemote::Server::IWinampServer * winampServer()
{
   return WinampRemote::Server::RPCExecutor::instance().getWinampServer();
}

string queryLogFormat(const char * strSender, long command, long data)
{

	stringstream sstr;
	sstr.str() = strSender;
	sstr << " sent  - query : " << WinampCommand(command) << " - data : " << data;
	return sstr.str();

}

string commandLogFormat(const char * strSender, long command, const char * strParam = NULL)
{
	  stringstream sstr;
	  sstr.str() = (char *) strSender;
	  sstr << " sent  - command : " << WinampCommand(command);
	  if (strParam)
		  sstr << " - parameter : " << strParam;
	  return sstr.str();
}


/*note  __RPC_FAR is literally nothing, but is left in for consistency
- none of the MIDL generated code should need direct modification*/

/**
 * @brief simple probing function
 * @param pszString the string
 */
void WAMessageProc(
    /* [string][in] */ unsigned char __RPC_FAR *pszString)
{

  std::string str = (char *) pszString;
  str += " sent hello";
  MainMessage(str.c_str());
  // TODO: need to implement WAExecutionStatus report status
  // MainStatus(waListening);

  // TODO: notification for exceptions

}

/**
 * @brief execute winamp command
 * @param pszString the string
 * @param command the winamp command
 */
void WAExecuteMessage(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [in] */ long command)
{

  MainMessage( commandLogFormat( (const char *) pszString, command).c_str());
  winampServer()->ExecuteCommand( static_cast<WinampCommand>(command) );
  // TODO: need to implement WAExecutionStatus report status
  // MainStatus(waListening);

  // TODO: notification for exceptions

}

/**
 * @brief execute winamp command with string parameter
 * @param pszString the string
 * @param pszParam the string parameter
 * @param command the winamp command
 */
void WAExecuteMessageString(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [string][in] */ unsigned char __RPC_FAR *pszParam,
    /* [in] */ long command)
{

	MainMessage( commandLogFormat( (const char *) pszString, command, (const char *) pszParam).c_str());
	// FIXME: eliminate the cast
	winampServer()->ExecuteStringCommand((const char *) pszParam, static_cast<WinampCommand>(command) );
	// TODO: need to implement WAExecutionStatus report status
	// MainStatus(waListening);

	// TODO: notification for exceptions


}

/**
 * @brief execute winamp function and return long integer result
 * @param pszString the string
 * @param command the winamp command
 * @param data a data parameter
 */
long WAIntegerResult(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [in] */ long command,
    /* [in] */ long data)
{

	MainMessage( queryLogFormat( (const char *) pszString, command, data).c_str());

	return winampServer()->QueryInt( (WinampCommand) command, data);
	// TODO: need to implement WAExecutionStatus report status
	// MainStatus(waListening);

	// TODO: notification for exceptions

}

/**
 * @brief execute winamp function and return string result
 * @param pszString the string
 * @param command the winamp command
 * @param data a data parameter
 */
long WAStringResult(
    /* [string][out][in] */ unsigned char __RPC_FAR pszString[ 260 ],
    /* [in] */ long command,
    /* [in] */ long data)
{

  MainMessage( queryLogFormat( (const char *) pszString, command, data).c_str());

  std::string str  = winampServer()->QueryString( static_cast<WinampCommand>(command), data).c_str();

  strcpy((char *) pszString, str.c_str());
  // TODO: need to implement WAExecutionStatus report status
  // MainStatus(waListening);

  // TODO: notification for exceptions

  // TODO: return non-zero when error handling is implemented
  return 0;

}

/**
 * @brief Shutdown function - do not call
 */
void WAShutdown(void)
{
    RpcMgmtStopServerListening(NULL);
    RpcServerUnregisterIf(NULL, NULL, FALSE);
    MainStatus("not listening");
    MainMessage("asked to close");
	// TODO: need to implement WAExecutionStatus report status
	// MainStatus(waListening);

	// TODO: notification for exceptions
}

/**
 * @brief sets a list in TStrings format with the command supplied
 * @param pszString the string
 * @param Buffer the text buffer
 * @param BufferLength the buffer length
 * @param command the winamp command
 */
void WASetStringList(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [in][size_is] */ byte __RPC_FAR Buffer[  ],
    /* [in] */ unsigned long BufferLength,
    /* [in] */ long command)
{

	// TODO: implement logging
	stringstream sstr;
	sstr.str() = (char *) Buffer;
	string line;
	while (std::getline(sstr, line))
	{
		winampServer()->ExecuteStringCommand(line.c_str(), static_cast<WinampCommand>(command));
	}


	MainStatus("listening...");
	// TODO: need to implement WAExecutionStatus report status
	// MainStatus(waListening);

	// TODO: notification for exceptions

}


inline static void populateBuffer(BUFFER * pBuffer, std::string& buffer)
{

	pBuffer->BufferLength = 0;
	int strlen = buffer.size();
	// FIXME check this results in the RPC RT returning the memory
	pBuffer->Buffer = (byte *) MIDL_user_allocate(strlen + 1);
	if (pBuffer->Buffer)
	{
		pBuffer->BufferLength = strlen + 1;
		memcpy(pBuffer->Buffer, buffer.c_str(), pBuffer->BufferLength);
	}

}

/**
 * @brief sets a list in TStrings format from the result of command supplied
 * @param pszString the string
 * @param pBuffer the text buffer
 * @param command the winamp command
 */
void WAGetStringList(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [out] */ BUFFER __RPC_FAR *pBuffer,
    /* [in] */ long command)
{


	std::stringstream list;

        int listLength = winampServer()->QueryInt(IPC_GETLISTLENGTH, 0);
        for (int i = 0 ; i < listLength ; i++)
        {
		if (i)
			list << std::endl;
		list << winampServer()->QueryString(static_cast<WinampCommand>(command), i);
	}

	populateBuffer(pBuffer, list.str());
  // TODO: no logging at all here
	MainStatus("listening...");
	// TODO: need to implement WAExecutionStatus report status
	// MainStatus(waListening);

	// TODO: notification for exceptions

}

/**
 * @brief sets a list in TStrings format from the result of commands supplied
 * @param pszString the string
 * @param pBuffer the text buffer
 * @param stringcommand the string query query
 * @param datacommand the data query
 * @param datadata the data parameter
 */
void WAGetStringDataList(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [out] */ BUFFER __RPC_FAR *pBuffer,
    /* [in] */ long stringcommand,
    /* [in] */ long datacommand,
    /* [in] */ long datadata)
{

	// TODO: no test coverage exists for this function
	std::stringstream list;
	for (int i = 0 ; i < 20; i++ )
	{
		if (i)
			list << std::endl;
		list << "string #" << i << std::endl;
		list << "value #" << i;
	}

	populateBuffer(pBuffer, list.str());
	MainStatus("listening...");
	// TODO: need to implement WAExecutionStatus report status
	// MainStatus(waListening);

	// TODO: notification for exceptions

}





