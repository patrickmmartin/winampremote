{ ************************************************************** }
{                                                                }
{   Winamp Delphi SDK 1.0                                        }
{   Winamp Interprocess Comunication API Unit                    }
{                                                                }
{   Slava Antonov (c) 2004                                       }
{   http://deadbeef.narod.ru/work/winampzone                     }
{                                                                }
{ ************************************************************** }

unit WinampAPI;

interface

{ Copyright (C) 2003 Nullsoft, Inc.

  This software is provided 'as-is', without any express or
  implied warranty. In no event will the authors be held 
  liable for any damages arising from the use of this software. 

  Permission is granted to anyone to use this software for
  any purpose, including commercial applications, and to 
  alter it and redistribute it freely, subject
  to the following restrictions:

   1. The origin of this software must not be misrepresented;
      you must not claim that you wrote the original software. 
      If you use this software in a product, an acknowledgment
      in the product documentation would be appreciated but
      is not required.

   2. Altered source versions must be plainly marked as such,
      and must not be misrepresented as being the original software.

   3. This notice may not be removed or altered
      from any source distribution. }

{ This is the modern replacement for the classic 'frontend.h'.
  Most of these updates are designed for in-process use, i.e.
  from a plugin.

  Message used to sent many messages to winamp's main window.
  Most all of the IPC_* messages involve sending the message
  in the form of:
    result = SendMessage(hwndWinamp, WM_WA_IPC, (parameter), IPC_*); }


uses
  Windows, Messages;


const
  WM_WA_IPC = WM_USER;
    { but some of them use WM_COPYDATA. be afraid. }


  IPC_GETVERSION = 0;
    { Version:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_GETVERSION);

      Version will be 0x20yx for winamp 2.yx. versions previous
      to Winamp 2.0 typically (but not always) use 0x1zyx for
      1.zx versions. Weird, I know. }


  IPC_GETREGISTEREDVERSION = 770;
    { TODO: ??? }


type
  TEnqueueFileWithMetaStruct = packed record
    szFileName: PChar;
    szTitle: PChar;
    Length: Integer;
  end;
  { send this to a IPC_PLAYFILE in a non WM_COPYDATA, 
    and you get the nice desired result. if title is NULL,
    it is treated as a "thing", otherwise it's assumed
    to be a file (for speed) }


const
  IPC_ENQUEUEFILE = 100;
  IPC_PLAYFILE = IPC_ENQUEUEFILE;
    { dont be fooled, this is really the same as IPC_ENQUEUEFILE.
      Sent as a WM_COPYDATA, with IPC_PLAYFILE as the dwData,
      and the string to play as the lpData. Just enqueues,
      does not clear the playlist or change the playback state. }


  IPC_DELETE = 101;
    { SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_DELETE);
      Use IPC_DELETE to clear Winamp's internal playlist. }


  IPC_STARTPLAY = 102;
    { starts playback. almost like hitting play in Winamp. }


  IPC_CHDIR = 103;
    { sent as a WM_COPYDATA, with IPC_CHDIR as the dwData,
      and the directory to change to as the lpData. }

  
  IPC_ISPLAYING = 104;
    { Res:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_ISPLAYING);
      
      If it returns 1, it is playing. if it returns 3, it is paused, 
      if it returns 0, it is not playing. }


  IPC_GETOUTPUTTIME = 105;
    { Res:= SendMessage(hwndWinamp, WM_WA_IPC, mode, IPC_GETOUTPUTTIME);
      
      Returns the position in milliseconds of the current
      track (mode = 0), or the track length, in seconds (mode = 1).
      Returns -1 if not playing or error. }


  IPC_JUMPTOTIME = 106;
    { (requires Winamp 1.60+)
      SendMessage(hwndWinamp,WM_WA_IPC,ms,IPC_JUMPTOTIME);

      IPC_JUMPTOTIME sets the position in milliseconds of the
      current song (approximately).
      Returns -1 if not playing, 1 on eof, or 0 if successful }


  IPC_GETMODULENAME = 109;
  IPC_EX_ISRIGHTEXE = 666;
    { Usually should not bother using these, but here goes:
      send a WM_COPYDATA with IPC_GETMODULENAME, and an internal
      flag gets set, which if you send a normal WM_WA_IPC message with
      IPC_EX_ISRIGHTEXE, it returns whether or not that filename
      matches. lame, I know. }


  IPC_WRITEPLAYLIST = 120;
    { (requires Winamp 1.666+)
      SendMessage(hwndWinamp,WM_WA_IPC,0,IPC_WRITEPLAYLIST);

      IPC_WRITEPLAYLIST writes the current playlist to
      \Winamp.m3u, and returns the current
      playlist position.
      Kinda obsoleted by some of the 2.x new stuff, but
      still good for when using a front-end (instead of a plug-in) }


  IPC_SETPLAYLISTPOS = 121;
    { (requires Winamp 2.0+)
      SendMessage(hwndWinamp, WM_WA_IPC, position, IPC_SETPLAYLISTPOS)

      IPC_SETPLAYLISTPOS sets the playlist position to 'position'. It
      does not change playback or anything, it just sets position, and
      updates the view if necessary }


  IPC_SETVOLUME = 122;
    { (requires Winamp 2.0+)
      SendMessage(hwndWinamp, WM_WA_IPC, Volume, IPC_SETVOLUME);

      IPC_SETVOLUME sets the volume of Winamp (from 0-255), but
      if Volume = -666 it returns current volume }


  IPC_SETPANNING = 123;
     { (requires Winamp 2.0+)
       SendMessage(hwndWinamp, WM_WA_IPC, Panning, IPC_SETPANNING);

       IPC_SETPANNING sets the panning of Winamp (from 0 (left)
       to 255 (right)). }


  IPC_GETLISTLENGTH = 124;
    { (requires Winamp 2.0+)
      Length:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_GETLISTLENGTH);

      IPC_GETLISTLENGTH returns the length of the current playlist, in
      tracks. }


  IPC_GETLISTPOS = 125;
    { (requires Winamp 2.05+)
      Pos:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_GETLISTPOS);

      IPC_GETLISTPOS returns the playlist position. A lot like
      IPC_WRITEPLAYLIST only faster since it doesn't have to write
      out the list. Heh, silly me. }


  IPC_GETINFO = 126;
    { (requires Winamp 2.05+)
      Info:= SendMessage(hwndWinamp, WM_WA_IPC, Mode, IPC_GETINFO);

      IPC_GETINFO returns info about the current playing song.
      The value it returns depends on the value of 'Mode':

      Mode      Meaning
      ------------------
      0         Samplerate (i.e. 44100)
      1         Bitrate  (i.e. 128)
      2         Channels (i.e. 2)
      3 (5+)    Video LOWORD=width HIWORD=height
      4 (5+)    > 65536, string (video description) }


  IPC_GETEQDATA = 127;
    { (requires Winamp 2.05+)
      Data:= SendMessage(hwndWinamp,WM_WA_IPC,pos,IPC_GETEQDATA);

      IPC_GETEQDATA queries the status of the EQ.
      The value returned depends on what 'pos' is set to:
      Value      Meaning
      ------------------
      0-9        The 10 bands of EQ data. 0-63 (+20db - -20db)
      10         The preamp value. 0-63 (+20db - -20db)
      11         Enabled. zero if disabled, nonzero if enabled.
      12         Autoload. zero if disabled, nonzero if enabled. }


  IPC_SETEQDATA = 128;
    { (requires Winamp 2.05+)
      SendMessage(hwndWinamp, WM_WA_IPC, Pos, IPC_GETEQDATA);
      SendMessage(hwndWinamp, WM_WA_IPC, Value, IPC_SETEQDATA);

      IPC_SETEQDATA sets the value of the last position retrieved
      by IPC_GETEQDATA. This is pretty lame, and we should provide
      an extended version that lets you do a MAKELPARAM(pos,value).
      someday...

      NEW IN 2.92+:
        If the high byte is set to 0xDB, then the third byte specifies
        which band, and the bottom word specifies the value. }


  IPC_ADDBOOKMARK = 129;
    { (requires Winamp 2.4+)
      Sent as a WM_COPYDATA, using IPC_ADDBOOKMARK, adds the specified
      file/url to the Winamp bookmark list.

      IN 5.0+:
        We use this as a normal WM_WA_IPC and the string:
        "filename\0title\0" to notify the library/bookmark editor
        that a bookmark was added. Note that using this message
        in this context does not actually add the bookmark.
        do not use :) }


  IPC_INSTALLPLUGIN = 130;
    { Not implemented, but if it was you could do a WM_COPYDATA with
      a path to a .wpz, and it would install it. }


  IPC_RESTARTWINAMP = 135;
    { (requires Winamp 2.2+)
    SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_RESTARTWINAMP);

    IPC_RESTARTWINAMP will restart Winamp (isn't that obvious ? :) }


  IPC_ISFULLSTOP = 400;
    { (requires winamp 2.7+ I think)
      Ret:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_ISFULLSTOP);

      Useful for when you're an output plugin, and you want to see
      if the stop/close is a full stop, or just between tracks.
      returns nonzero if it's full, zero if it's just a new track. }


  IPC_INETAVAILABLE = 242;
    { (requires Winamp 2.05+)
      Val:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_INETAVAILABLE);

      IPC_INETAVAILABLE will return 1 if the Internet connection
      is available for Winamp. }


  IPC_UPDTITLE = 243;
  { TODO : ???????????, ????? ?????????? ??????? ?????????? }
    { (requires Winamp 2.2+)
      SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_UPDTITLE);

      IPC_UPDTITLE will ask Winamp to update the informations
      about the current title. }


  IPC_REFRESHPLCACHE = 247;
    { (requires Winamp 2.2+)
      SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_REFRESHPLCACHE);

      IPC_REFRESHPLCACHE will flush the playlist cache buffer.
      (send this if you want it to go refetch titles for tracks) }


  IPC_GET_SHUFFLE = 250;
    { (requires Winamp 2.4+)
      Val:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_GET_SHUFFLE);

      IPC_GET_SHUFFLE returns the status of the Shuffle
      option (1 if set) }


  IPC_GET_REPEAT = 251;
    { (requires Winamp 2.4+)
      Val:= SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_GET_REPEAT);

      IPC_GET_REPEAT returns the status of the Repeat option (1 if set) }


  IPC_SET_SHUFFLE = 252;
    { (requires Winamp 2.4+)
      SendMessage(hwndWinamp, WM_WA_IPC, Value, IPC_SET_SHUFFLE);

      IPC_SET_SHUFFLE sets the status of the Shuffle
      option (1 to turn it on) }


  IPC_SET_REPEAT = 253;
    { (requires Winamp 2.4+)
      SendMessage(hwndWinamp, WM_WA_IPC, Value, IPC_SET_REPEAT);

      IPC_SET_REPEAT sets the status of the Repeat
      option (1 to turn it on) }


  IPC_ENABLEDISABLE_ALL_WINDOWS = 259;
    { (requires Winamp 2.9+)
      SendMessage(hwndWinamp, WM_WA_IPC, Value, IPC_MBOPENREAL);

      Sending with Value = 0xdeadbeef as the param disables all
      winamp windows, any other values will enable all winamp windows. }


  IPC_GETWND = 260;
    { (requires Winamp 2.9+)
      hwnd:= SendMessage(hwndWinamp,
          WM_WA_IPC,
          IPC_GETWND_xxx,
          IPC_GETWND);

      Returns the HWND of the window specified: }


  IPC_GETWND_EQ = 0;
  IPC_GETWND_PE = 1;
  IPC_GETWND_MB = 2;
  IPC_GETWND_VIDEO = 3;


  IPC_ISWNDVISIBLE = 261;
    { ((requires Winamp 2.9+)
      Visible:= SendMessage(hwndWinamp,
          WM_WA_IPC,
          IPC_GETWND_xxx,
          IPC_ISWNDVISIBLE); }


{ ******************************************************************* }
{ ***************** in-process only (WE LOVE PLUGINS) *************** }
{ ******************************************************************* }


  IPC_SETSKIN = 200;
    { (requires Winamp 2.04+, plug-ins)
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(PChar(SkinName)),
          IPC_SETSKIN);

      IPC_SETSKIN sets the current skin to "skinname". Note
      that skinname can be the name of a skin, a skin .zip file,
      with or without path.
      If path isn't specified, the default search path is the
      winamp skins directory. }


  IPC_GETSKIN = 201;
    { (requires Winamp 2.04+, plug-ins)
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(PChar(SkinNameBuffer)),
          IPC_GETSKIN);

      IPC_GETSKIN puts the directory where skin bitmaps can be found
      into  skinname_buffer.
      SkinNameBuffer must be MAX_PATH characters in length.
      When using a .zip'd skin file, it'll return a temporary directory
      where the ZIP was decompressed. }


  IPC_EXECPLUG = 202;
    { (requires Winamp 2.04+, plug-ins )
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(PChar('vis_file.dll)),
          IPC_EXECPLUG);

      IPC_EXECPLUG executes a visualization plug-in pointed to by WPARAM.
      The format of this string can be:
      "vis_whatever.dll"
      "vis_whatever.dll,0" (first mod, file in winamp plug-in dir)
      "C:\\dir\\vis_whatever.dll,1" }


  IPC_GETPLAYLISTFILE = 211;
    { (requires Winamp 2.04+, plug-ins )
      var
        szFileName: PChar;
      szFileName:= SendMessage(hwndWinamp,
          WM_WA_IPC,
          Index,
          IPC_GETPLAYLISTFILE);

      IPC_GETPLAYLISTFILE gets the filename of the playlist entry [index].
      Returns a pointer to it.
      Returns NULL/NIL on error. }


  IPC_GETPLAYLISTTITLE = 212;
    { (requires Winamp 2.04+, plug-ins)
      szTitle:= PChar(SendMessage(hwndWinamp,
                    WM_WA_IPC,
                    Index,
                    IPC_GETPLAYLISTTITLE);

      IPC_GETPLAYLISTTITLE gets the title of the playlist entry [index].
      returns a pointer to it. returns NULL on error. }


  IPC_GETHTTPGETTER = 240; { TODO : check }
    { Retrieves a function pointer to a HTTP retrieval function.
      If this is unsupported, returns 1 or 0.
      The function should be:
        type
          THTTPRetrieveFileProc = function (hwnd: HWND;
              szURL: PChar;
              szFile: PChar;
              szDlgTitle: PChar): Integer; cdecl;
        var
          HTTPRetrieveFile: THTTPRetrieveFileProc;
        begin
          @HTTPRetrieveFile:= SendMessage(hwndWinamp,
              WM_WA_IPC,
              0,
              IPC_GETHTTPGETTER);
          ...
        end;

        If you call this function, with a parent window, a URL, an output
        file, and a dialog title, it will return 0 on successful
        download, 1 on error. }


  IPC_MBOPEN = 241;
    { (requires Winamp 2.05+)
      SendMessage(hwndWinamp, WM_WA_IPC, 0, IPC_MBOPEN);
      SendMessage(hwndWinamp,WM_WA_IPC,(WPARAM)url,IPC_MBOPEN);

      IPC_MBOPEN will open a new URL in the minibrowser. if url
      is NULL, it will open the Minibrowser window. }



  IPC_CHANGECURRENTFILE = 245;
    { (requires Winamp 2.05+)
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(PChar(FileName)),
          IPC_CHANGECURRENTFILE);

      IPC_CHANGECURRENTFILE will set the current playlist item. }


  IPC_GETMBURL = 246;
    { (requires Winamp 2.2+)
      var
        Buf: array[0..4095] of Char;
      begin
        SendMessage(hwndWinamp,
            WM_WA_IPC,
            WPARAM(PChar(Buf)),
            IPC_GETMBURL);
        ...
      end;

      IPC_GETMBURL will retrieve the current Minibrowser URL
      into buffer. Buffer must be at least 4096 bytes long. }


  IPC_MBBLOCK = 248;
    { (requires Winamp 2.4+)
      SendMessage(hwndWinamp, WM_WA_IPC, Value, IPC_MBBLOCK);

      IPC_MBBLOCK will block the Minibrowser from updates
      if value is set to 1 }


  IPC_MBOPENREAL = 249;
    { (requires Winamp 2.4+)
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(PChar(Url)),
          IPC_MBOPENREAL);

      IPC_MBOPENREAL works the same as IPC_MBOPEN except that
      it will works even if IPC_MBBLOCK has been set to 1 }


  IPC_ADJUST_OPTIONSMENUPOS = 280; { TODO : What is Adjust_Offset? }
    { (requires Winamp 2.9+)
      NewPos:= SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(Adjust_Offset),
          IPC_ADJUST_OPTIONSMENUPOS);

      Moves where winamp expects the Options menu in the main menu.
      Useful if you wish to insert a menu item above the
      options/skins/vis menus. }


  IPC_GET_HMENU = 281;
    { (requires Winamp 2.9+)
      hMenu:= HMENU(SendMessage(hwndWinamp,
          WM_WA_IPC,
          Data,
          IPC_GET_HMENU);

      Values for "Data":
        0: main popup menu
        1: main menubar file menu
        2: main menubar options menu
        3: main menubar windows menu
        4: main menubar help menu
        Other values will return NULL. }


type
  TBaseFileInfo = packed record
  { Filled by User }
    szFileName: PChar;
    QuickCheck: Integer;
      { set to 0 to always get, 1 for quick, 2 for default
        If 2, quickCheck will be set to 0 if quick wasnot used }

  { Filled in by winamp }
    Length: Integer;
    szTitle: PChar;
    TitleLen: Integer;
  end;


  TExtendedFileInfo = packed record
    szFileName: PChar;
    szMetadata: PChar;
    szRet: PChar;
    RetLen: Integer;
  end;


const
  IPC_GET_EXTENDED_FILE_INFO = 290; { TODO : check }
  IPC_GET_EXTENDED_FILE_INFO_HOOKABLE = 296;
    { (requires Winamp 2.9+)
      To use, create an TExtendedFileInfo, point the values "szFileName"
      and "szMetadata" to the filename and metadata field you wish to
      query, and "Ret" to a buffer, with RetLen to the length of that
      buffer, and then
        SendMessage(hwndWinamp,
            WM_WA_IPC,
            WPARAM(@FileInfoEx),
            IPC_GET_EXTENDED_FILE_INFO);

      The results should be in the buffer pointed to by ret.
      Returns 1 if the decoder supports a getExtendedFileInfo method }


  IPC_GET_BASIC_FILE_INFO = 291;
    { var
        FileInfo: TBaseFileInfo;
      begin
        FileInfo.szFileName:= 'C:\Music\Rammstein\Mutter\Mutter.ogg';
        FileInfo.QuickCheck:= 2;
        SendMessage(hwndWinamp,
            WM_WA_IPC,
            WPARAM(@FileInfo),
            IPC_GET_BASIC_FILE_INFO);
        ...
      end; }


  IPC_GET_EXTLIST = 292;
    { szBuf:= PChar(SendMessage(hwndWinamp,
                        WM_WA_IPC,
                        Data,
                       IPC_GET_EXTLIST);

      Returns doublenull delimited. GlobalFree() it when done.
      If "Data" is 0, returns raw extlist, if 1, returns something
      suitable for GetOpenFileName }


type
  TInfoBoxParams = packed record
  { Filled by User }
    hwndParent: THandle;
    szFileName: PChar;
  end;


const
  IPC_INFOBOX = 293;
    { SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(@InfoBoxParams),
          IPC_INFOBOX); }


  IPC_SET_EXTENDED_FILE_INFO = 294;
    { Pass a pointer to the a extendedFileInfoStruct in wParam
      (requires Winamp 2.9+)

      To use, create an TExtendedFileInfo, point the values "szFileName"
      and "szMetadata" to the filename and metadata field you wish to
      write in Ret. (RetLen is not used). And then
        SendMessage(hwndWinamp,
            WM_WA_IPC,
            WPARAM(@FileInfoEx),
            IPC_SET_EXTENDED_FILE_INFO);

      Returns 1 if the Metadata is supported
      Call IPC_WRITE_EXTENDED_FILE_INFO once you're done setting all
      the metadata you want to update }


  IPC_WRITE_EXTENDED_FILE_INFO = 295;
    { (requires Winamp 2.9+)
      Writes all the metadata set thru IPC_SET_EXTENDED_FILE_INFO
      to the file returns 1 if the file has been successfully updated,
      0 if error }


  IPC_FORMAT_TITLE = 297; { TODO : check }
    type
      TFormatTitle = packed record
        szSpec: PChar;
          { nil - default Winamp spec }
        Ptr: Pointer;
        szOut: PChar;
        OutLen: Integer;
        TagFunc: function(szTag: PChar; Ptr: Pointer): PChar; cdecl;
          { return 0 if not found }
        TagFreeFunc: procedure(szTag: PChar; Ptr: Pointer); cdecl;
      end;


const
  IPC_GETUNCOMPRESSINTERFACE = 331;
    { Returns a function pointer to Uncompress():
      function Uncompress(pbDest: PByte; var nDestLen: Cardinal;
        pbSrc: PByte; nSrcLen: Cardinal): Integer; cdecl;

      Right out of zlib, useful for decompressing zlibbed data.
      If you pass the wParam of 0x10100000, it will return a
      PWAInflateStruct to an inflate API. }

    type
      PWAInflateStruct = ^TWAInflateStruct;
      TWAInflateStruct = packed record
        InflateReset: function(pStream: Pointer): Integer; cdecl;
        InflateInit: function(pStream: Pointer; szVersion: PChar;
                       iStreamSize: Integer): Integer; cdecl;
        Inflate: function(pStream: Pointer; iFlush: Integer): Integer;
                   cdecl;
        InflateEnd: function(pStream: Pointer): Integer; cdecl;
        Crc32: function(nCrc: Cardinal; pbBuf: PByte;
                 nBufLen: Cardinal): Cardinal; cdecl;
      end;


type
  TPrefsDlgRec = packed record
    hInstance: THandle;
      { The DLL instance where the dialog resource is located }
    nDlgID: Cardinal;
      { ID of the dialog }
    DlgWndProc: function(hwndDlg: HWND; uMsg: UINT; wParam: WPARAM;
                  lParam: LPARAM): LongBool; stdcall;
      { Dialog window procedure }
    szName: PChar;
      { The name of the prefs page in the prefs }
    iWhere: Integer;
      { 0 - Options;
        1 - Plug-ins;
        2 - Skins;
        3 - Bookmarks;
        4 - Prefs. }
    end; { TPrefsDlgRec }


const        
  IPC_ADD_PREFS_DLG = 332;
  IPC_REMOVE_PREFS_DLG = 333;
    { (requires Winamp 2.9+)
      To use, allocate a TPrefsDlgRec structure (either on the heap
      or some global data, but NOT on the stack), initialze the members:
        "hInst" to the DLL instance where the resource is located;
        "dlgID" to the ID of the dialog;
        "Proc" to the window procedure for the dialog;
        "name" to the name of the prefs page in the prefs.
        "Where" to 0 (eventually we may add more options).
        Then:
          SendMessage(hwndWinamp,
              WM_WA_IPC,
              WPARAM(@PrefsRec,
              IPC_ADD_PREFS_DLG);

        You can also IPC_REMOVE_PREFS_DLG with the address of the
        same PrefsRec, but you shouldn't really ever have to. }


  IPC_OPENPREFSTOPAGE = 380;
    { wParam - is an id of a builtin page, or a @prefsDlgRec of prefs
      page to open }


  IPC_GETINIFILE = 334; { TODO : check }
    { Returns a pointer to winamp.ini }


  IPC_GETINIDIRECTORY = 335;
    { Returns a pointer to the directory to put config files in
      (if you dont want to use winamp.ini) }


  IPC_SPAWNBUTTONPOPUP = 361;
    { Spawns button's pop-up menus:
      wParam:
        0 = eject;
        1 = previous;
        2 = next;
        3 = pause;
        4 = play;
        5 = stop }


  IPC_OPENURLBOX = 360;
    { Pass a HWND (wParam) to a parent, returns a HGLOBAL that needs
      to be freed with GlobalFree(), if successful (<> 0) }


  IPC_OPENFILEBOX = 362;
    { wParam - HWND to a parent }


  IPC_OPENDIRBOX = 363;
    { wParam - HWND to a parent }


  IPC_SETDIALOGBOXPARENT = 364;
    { Pass an HWND to a parent. Call this if you take over the whole UI
      so that the dialogs are not appearing on the bottom right of the
      screen since the main winamp window is at 3000x3000, call again
      with NULL to reset }



  IPC_GET_GENSKINBITMAP = 503;
    { Returns some information about the current skin.
      wParam:
        0 for a copy of the skin HBITMAP;
        1 for name of font to use for playlist editor likeness;
        2 for font charset
        3 for font size }


  IPC_GET_EMBEDIF = 505;
    { Pass in wParam an PEmbedWindowState.
      Returns an HWND embedWindow(embedWindowState *);
      If the data is NULL, otherwise returns the HWND directly }


type
  PEmbedWindowState = ^TEmbedWindowState;
  TEmbedWindowState = packed record
    hwnd: HWND;
      { HWND of the window }
    iFlags: Integer;
      { see below... }
    Rect: TRect;
    Ptr: Pointer;
      { for application use }
    ExtraData: array[0..64-1] of Integer;
      { for internal winamp use }
  end;


const
  EMBED_FLAGS_NORESIZE = 1;
    { Set this bit in TEmbedWindowState.iFlags to keep window
      from being resizable }
  EMBED_FLAGS_NOTRANSPARENCY = 2;
    { Set this bit in TEmbedWindowState.iFlags to make gen_ff
      turn transparency off for this wnd }


  IPC_EMBED_ENUM = 532;
    { wParam = PEmbedEnumStruct }


type
  PEmbedEnumStruct = ^TEmbedEnumStruct;
  TEmbedEnumStruct = packed record
    EnumProc: function(lpEmbedWindowState: PEmbedWindowState;
                lpEmbedEnumStruct: PEmbedEnumStruct): Integer; cdecl;
      { Return 1 to stop enumeration }
    iUserData: Integer;
  end;


const
  IPC_EMBED_ISVALID = 533;


  IPC_CONVERTFILE = 506;
    { (requires Winamp 2.92+)
      Converts a given file to a different format (PCM, MP3, etc...
      To use, pass a pointer to a TFileConvertStruct struct
      This struct can be either on the heap or some global
      data, but NOT on the stack. At least, until the conversion is done.

      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(@lpFileConvertStruct),
          IPC_CONVERTFILE);

      Return value:
        0 - Can't start the conversion. Look at
            lpFileConvertStruct.Error for details.
        1 - Conversion started. Status messages will be sent to the
            specified CallBackHwnd.

      Be sure to call IPC_CONVERTFILE_END when your callback window
      receives the IPC_CB_CONVERT_DONE message. }


type
  PFileConvertStruct = ^TFileConvertStruct;
  TFileConvertStruct = packed record
  { Filled by plug-in }
    szSrcFile: PChar;
    szDestFile: PChar;
    DestFormat: array[0..8-1] of Integer;
      { like 'PCM ',srate,nch,bps }
    hwndCallBack: HWND;
      { window that will receive the IPC_CB_CONVERT
        notification messages }
  { Filled by Winamp }
    szError: PChar;
      { if IPC_CONVERTFILE returns 0, the reason will be here }
    nBytesDone: UINT;
    nBytesTotal: UINT;
    nBytesOut: UINT;
      { you can look at both of these values for speed statistics }
    iKillSwitch: Integer;
      { don't set it manually, use IPC_CONVERTFILE_END }
    ExtraData: array[0..64-1] of Integer;
      { for internal winamp use }
  end; { TFileConvertStruct }


const
  IPC_CONVERTFILE_END = 507;
    { (requires Winamp 2.92+)
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(@WAFileConvertStruct),
          IPC_CONVERTFILE_END);

      Stop/ends a convert process started from IPC_CONVERTFILE
      You need to call this when you receive the IPC_CB_CONVERTDONE
      message or when you want to abort a conversion process. }


  IPC_CONVERT_CONFIG = 508; { TODO : ??? }
  IPC_CONVERT_CONFIG_END = 509;

type
  PConvertConfigStruct = ^TConvertConfigStruct;
  TConvertConfigStruct = packed record
    hwndParent: HWND;
    iFormat: Integer;

  { filled in by winamp.exe }
    hwndConfig: HWND;
    ExtraData: array[0..8-1] of Integer;
  end; { TConvertConfigStruct }


  TConverterEnumFmtStruct = packed record
    EnumProc: procedure(iUserData: Integer; szDesc: PChar;
                iFourCC: Integer); cdecl;
    iUserData: Integer;
  end; { TConverterEnumFmtStruct }


const
  IPC_CONVERT_CONFIG_ENUMFMTS = 510;
    { (requires Winamp 2.92+) }


  IPC_BURN_CD = 511;
    { (requires Winamp 5.0+)
      SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(@BurnCDStruct),
          IPC_BURN_CD); }


type
  PBurnCDStruct = ^TBurnCDStruct;
  TBurnCDStruct = packed record
    chCDLetter: Char;
    szPlaylistFile: PChar;
    hwndCallback: HWND;
  { filled in by winamp: }
    szError: PChar;
  end; { TBurnCDStruct }


  PConvertSetPriority = ^TConvertSetPriority;
  TConvertSetPriority = packed record
    lpConfertFileStruct: PFileConvertStruct;
    iPriority: Integer;
  end; { TConvertSetPriority }


const
  IPC_CONVERT_SET_PRIORITY = 512;
    { SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(@ConvertSetPriority),
          IPC_CONVERT_SET_PRIORITY); }


type
  PHookTitleStruct = ^THookTitleStruct;
  THookTitleStruct = packed record
    szFileName: PChar;
    szTitle: PChar;
    iLength: Integer;
    iForseUseFormatting: Integer;
      { Can set this to 1 if you want to force a url to use title
        formatting shit }
  end; { THookTitleStruct }


const
  IPC_HOOK_TITLES = 850; { TODO : check }
    { Return TRUE if you hook this }


  IPC_GETSADATAFUNC = 800; { TODO : check }
    { SendMessage(hwndWinamp,
          WM_WA_IPC,
          Value,
          IPC_GETSADATAFUNC);

      Value:
        0 - returns a char *export_sa_get() that returns 150
            bytes of data
        1 - returns a export_sa_setreq(int want); }


  IPC_ISMAINWNDVISIBLE = 900;


  IPC_SETPLEDITCOLORS = 920;
    { SendMessage(hwndWinamp,
          WM_WA_IPC,
          WPARAM(@SetPLColorsStruct),
          IPC_SETPLEDITCOLORS); }


type
  PSetPLColorsStruct = ^TSetPLColorsStruct;
  TSetPLColorsStruct = packed record
    nNumElems: UINT;
    pElems: PUINT;
    hBitmap: HBITMAP;
      { set if you want to override }
  end; { TSetPLColorsStruct }


{ The following IPC use TWASpawnMenuParams as parameter }
const
  IPC_SPAWNEQPRESETMENU      = 933;
  IPC_SPAWNFILEMENU          = 934; { menubar }
  IPC_SPAWNOPTIONSMENU       = 935; { menubar }
  IPC_SPAWNWINDOWSMENU       = 936; { menubar }
  IPC_SPAWNHELPMENU          = 937; { menubar }
  IPC_SPAWNPLAYMENU          = 938; { menubar }
  IPC_SPAWNPEFILEMENU        = 939; { menubar }
  IPC_SPAWNPEPLAYLISTMENU    = 940; { menubar }
  IPC_SPAWNPESORTMENU        = 941; { menubar }
  IPC_SPAWNPEHELPMENU        = 942; { menubar }
  IPC_SPAWNMLFILEMENU        = 943; { menubar }
  IPC_SPAWNMLVIEWMENU        = 944; { menubar }
  IPC_SPAWNMLHELPMENU        = 945; { menubar }
  IPC_SPAWNPELISTOFPLAYLISTS = 946;


type
  PWASpawnMenuParams = ^TWASpawnMenuParams;
  TWASpawnMenuParams = packed record
    hWnd: HWND;
    X, Y: Integer; { in screen coordinates }
  end; { TWASpawnMenuParams }

  PWASpawnMenuParams2 = ^TWASpawnMenuParams2;
{ TWASpawnMenuParams2 is used by the menubar submenus }
  TWASpawnMenuParams2 = packed record
    hWnd: HWND;
    X, Y: Integer; { in screen coordinates }
    nWidth, nHeight: UINT;
  end; { TWASpawnMenuParams2 }


const
  WM_WA_SYSTRAY = WM_USER + 1;
    { System tray sends this (you might want to simulate it) }


  WM_WA_MPEG_EOF = WM_USER + 2;
    { input plugins send this when they are done playing back }


{ Video stuff }
  IPC_IS_PLAYING_VIDEO = 501;
    { Returns > 1 if playing, 0 if not, 1 if old version (so who knows) :)}
  IPC_GET_IVIDEOOUTPUT = 500;
    { See below for IVideoOutput interface }
  function VIDEO_MAKETYPE(A, B, C, D: Byte): UINT;
    { ((A) | ((B)<<8) | ((C)<<16) | ((D)<<24)) }
const
  VIDUSER_SET_INFOSTRING = $1000;
  VIDUSER_GET_VIDEOHWND  = $1001;
  VIDUSER_SET_VFLIP      = $1002;


type
  TYV12_PLANE = packed record
    pbBaseAddr: PByte;
    nRowBytes: UINT;
  end; { TYV12_PLANE }

  TYV12_PLANES = packed record
    y: TYV12_PLANE;
    u: TYV12_PLANE;
    v: TYV12_PLANE;
  end; { TYV12_PLANES }

(*
class IVideoOutput
{
  public:
    virtual ~IVideoOutput() { }
    virtual int open(int w, int h, int vflip, double aspectratio,
      unsigned int fmt)=0;
    virtual void setcallback(LRESULT (*msgcallback)(void *token,
      HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam),
      void *token) { }
    virtual void close()=0;
    virtual void draw(void *frame)=0;
    virtual void drawSubtitle(SubsItem *item) { }
    virtual void showStatusMsg(const char *text) { }
    virtual int get_latency() { return 0; }
    virtual void notifyBufferState(int bufferstate) { } /* 0-255*/

    virtual int extended(int param1, int param2, int param3)
      { return 0; } // Dispatchable, eat this!
};
*)


const
{ These messages are callbacks that you can grab by subclassing
  the winamp window }

  IPC_CB_ONSHOWWND = 600;
  IPC_CB_ONHIDEWND = 601;
  IPC_CB_GETTOOLTIP = 602;
  { wParam = ... }
    IPC_CB_WND_EQ    = 0; { use one of these for the wParam }
    IPC_CB_WND_PE    = 1;
    IPC_CB_WND_MB    = 2;
    IPC_CB_WND_VIDEO = 3;
    IPC_CB_WND_MAIN  = 4;


  IPC_CB_MISC = 603;
  { wParam = ... }
    IPC_CB_MISC_TITLE     = 0;
    IPC_CB_MISC_VOLUME    = 1; { volume/pan }
    IPC_CB_MISC_STATUS    = 2;
    IPC_CB_MISC_EQ        = 3;
    IPC_CB_MISC_INFO      = 4;
    IPC_CB_MISC_VIDEOINFO = 5;


  IPC_CB_CONVERT_STATUS = 604;
    { wParam value goes from 0 to 100 (percent) }
  IPC_CB_CONVERT_DONE   = 605;


  IPC_ADJUST_FFWINDOWSMENUPOS = 606; { TODO : check }
    { (requires Winamp 2.9+)
      iNewPos:= SendMessage(hwndWinamp,
                    WM_WA_IPC,
                    (WPARAM)AdjustOffset,
                    IPC_ADJUST_FFWINDOWSMENUPOS);

      Moves where winamp expects the freeform windows in the menubar
      windows main menu. Useful if you wish to insert a menu item
      above extra freeform windows. }


  IPC_ISDOUBLESIZE = 608;


  IPC_ADJUST_FFOPTIONSMENUPOS = 609; { TODO : check }
    { (requires Winamp 2.9+)

      iNewPos:= SendMessage(hwndWinamp,
                    WM_WA_IPC,
                    (WPARAM)AdjustOffset,
                    IPC_ADJUST_FFOPTIONSMENUPOS);

      Moves where winamp expects the freeform preferences item in the
      menubar windows main menu. Useful if you wish to insert a
      menu item above preferences item. }


  IPC_GETTIMEDISPLAYMODE = 610;
    { Returns 0 if displaying elapsed time or 1 if displaying
      remaining time }


  IPC_SETVISWND = 611;
    { wParam is hWnd, setting this allows you to receive
      ID_VIS_NEXT/PREVOUS/RANDOM/FS wm_commands }
  ID_VIS_NEXT       = 40382;
  ID_VIS_PREV       = 40383;
  ID_VIS_RANDOM     = 40384;
  ID_VIS_FS         = 40389;
  ID_VIS_CFG        = 40390;
  ID_VIS_MENU       = 40391;

  IPC_GETVISWND = 612;
    { Returns the vis cmd handler hWnd }

  IPC_ISVISRUNNING = 613;

  IPC_CB_VISRANDOM = 628;
    { wParam is status of random }


  IPC_SETIDEALVIDEOSIZE = 614;
    { Sent by winamp to winamp, trap it if you need it.
      nWidth:= HIWORD(wParam),
      nHeight:= LOWORD(wParam) }


  IPC_GETSTOPONVIDEOCLOSE = 615;
  IPC_SETSTOPONVIDEOCLOSE = 616;


type
  TTransAccelStruct = packed record
    hWnd: HWND;
    uMsg: UINT;
    wParam: WPARAM;
    lParam: LPARAM;
  end; { TTransAccelStruct }


const
  IPC_TRANSLATEACCELERATOR = 617;


type
{ Send this as wParam to an IPC_PLCMD, IPC_MBCMD, IPC_VIDCMD }
  PWindowCommand = ^TWindowCommand;
  TWindowCommand = packed record
    uCmd: UINT;
    X, Y: Integer;
    iAlign: Integer;
  end; { TWindowCommand }


const
  IPC_CB_ONTOGGLEAOT = 618; 
  IPC_GETPREFSWND = 619;

  IPC_SET_PE_WIDTHHEIGHT = 620;
    { wParam is a pointer to a POINT structure that holds width & height }


  IPC_GETLANGUAGEPACKINSTANCE = 621;

  IPC_CB_PEINFOTEXT = 622;
    { wParam is a string, ie: "04:21/45:02" }

  IPC_CB_OUTPUTCHANGED = 623;
    { output plugin was changed in config }

  IPC_GETOUTPUTPLUGIN = 625;

  IPC_SETDRAWBORDERS = 626;
  IPC_DISABLESKINCURSORS = 627;
  IPC_CB_RESETFONT = 629;

  IPC_IS_FULLSCREEN = 630;
    { Returns 1 if video or vis is in fullscreen mode }

  IPC_SET_VIS_FS_FLAG = 631;
    { a vis should send this message with 1/as param to notify
      winamp that it has gone to or has come back from fullscreen mode }


  IPC_SHOW_NOTIFICATION = 632;
  IPC_GETSKININFO = 633;

{ >>>>>>>>>>> Next is 634 }


{ See note for the TWindowCommand }
  IPC_PLCMD    = 1000;
    PLCMD_ADD  = 0;
    PLCMD_REM  = 1;
    PLCMD_SEL  = 2;
    PLCMD_MISC = 3;
    PLCMD_LIST = 4;

  IPC_MBCMD       = 1001;
    MBCMD_BACK    = 0;
    MBCMD_FORWARD = 1;
    MBCMD_STOP    = 2;
    MBCMD_RELOAD  = 3;
    MBCMD_MISC    = 4;

  IPC_VIDCMD          = 1002;
    VIDCMD_FULLSCREEN = 0;
    VIDCMD_1X         = 1;
    VIDCMD_2X         = 2;
    VIDCMD_LIB        = 3;
    VIDPOPUP_MISC     = 4;


  IPC_MBURL          = 1003;
    { sets the URL }

  IPC_MBGETCURURL    = 1004;
    { copies the current URL into wParam (have a 4096 buffer ready) }

  IPC_MBGETDESC      = 1005;
    { copies the current URL description into wParam
     (have a 4096 buffer ready) }

  IPC_MBCHECKLOCFILE = 1006;
    { checks that the link file is up to date (otherwise updates it).
      wParam = parent HWND }

  IPC_MBREFRESH      = 1007;
    { refreshes the "now playing" view in the library }

  IPC_MBGETDEFURL    = 1008;
    { copies the default URL into wParam (have a 4096 buffer ready) }

  IPC_STATS_LIBRARY_ITEMCNT = 1300;
    { updates library count status }


{ IPC 2000-3000 reserved for freeform messages, see gen_ff/ff_ipc.h }
  IPC_FF_FIRST = 2000;
  IPC_FF_LAST  = 3000;


  IPC_GETDROPTARGET = 3001;


  IPC_PLAYLIST_MODIFIED = 3002;
    { Sent to main wnd whenever the playlist is modified }


  IPC_PLAYING_FILE = 3003;
    { Sent to main wnd with the file as wParam whenever a file is played }


  IPC_FILE_TAG_MAY_HAVE_UPDATED = 3004;
    { Sent to main wnd with the file as wParam whenever a file tag
      might be updated }


  IPC_ALLOW_PLAYTRACKING = 3007;
    { Send nonzero (wParam) to allow, zero to disallow }


  IPC_HOOK_OKTOQUIT = 3010;
    { Return 0 to abort a quit, nonzero if quit is OK }


  IPC_WRITECONFIG = 3011;
    { Pass (wParam) 2 to write all, 1 to write playlist + common,
      0 to write common + less common }


  IPC_REGISTER_WINAMP_IPCMESSAGE = 65536;
    { Pass a string to be the name to register, and returns
      a value > 65536, which is a unique value you can use
      for custom WM_WA_IPC messages. }
   

{ ******************************************************************* }
{ Finally there are some WM_COMMAND messages that you can use to send }
{ Winamp misc commands.                                               }
{                                                                     }
{ To send these, use:                                                 }
{                                                                     }
{ SendMessage(hwndWinamp, WM_COMMAND,command_name,0);                 }
{ ******************************************************************* }

{ This is simply menu items ids. You can see more menu items ids
  by any resource viewer utility in the winamp.exe }
  WINAMP_OPTIONS_EQ              = 40036; // toggles the EQ window
  WINAMP_OPTIONS_PLEDIT          = 40040; // toggles the playlist window
  WINAMP_VOLUMEUP                = 40058; // turns the volume up a little
  WINAMP_VOLUMEDOWN              = 40059; // turns the volume down a little
  WINAMP_FFWD5S                  = 40060; // fast forwards 5 seconds
  WINAMP_REW5S                   = 40061; // rewinds 5 seconds


{ The following are the five main control buttons, with optionally shift
  or control pressed (for the exact functions of each, just try it out) }
  WINAMP_BUTTON1                 = 40044;
  WINAMP_BUTTON2                 = 40045;
  WINAMP_BUTTON3                 = 40046;
  WINAMP_BUTTON4                 = 40047;
  WINAMP_BUTTON5                 = 40048;
  WINAMP_BUTTON1_SHIFT           = 40144;
  WINAMP_BUTTON2_SHIFT           = 40145;
  WINAMP_BUTTON3_SHIFT           = 40146;
  WINAMP_BUTTON4_SHIFT           = 40147;
  WINAMP_BUTTON5_SHIFT           = 40148;
  WINAMP_BUTTON1_CTRL            = 40154;
  WINAMP_BUTTON2_CTRL            = 40155;
  WINAMP_BUTTON3_CTRL            = 40156;
  WINAMP_BUTTON4_CTRL            = 40157;
  WINAMP_BUTTON5_CTRL            = 40158;


  WINAMP_FILE_PLAY               = 40029;
    { pops up the load file(s) box }
  WINAMP_FILE_DIR                = 40187;
    { pops up the load directory box }
  WINAMP_OPTIONS_PREFS           = 40012;
    { pops up the preferences }
  WINAMP_OPTIONS_AOT             = 40019;
    { toggles always on top }
  WINAMP_HELP_ABOUT              = 40041;
    { pops up the about box :) }


  ID_MAIN_PLAY_AUDIOCD1          = 40323;
    { starts playing the audio CD in the first CD reader }
  ID_MAIN_PLAY_AUDIOCD2          = 40323;
    { plays the 2nd }
  ID_MAIN_PLAY_AUDIOCD3          = 40323;
    { plays the 3nd }
  ID_MAIN_PLAY_AUDIOCD4          = 40323;
    { plays the 4nd }


  WINAMP_SORT_BY_TITLE           = 40209; // sorts play list by title
  WINAMP_SORT_BY_FILENAME        = 40210; // sorts play list by filename
  WINAMP_SORT_BY_PATH            = 40211; // sorts play list by path and filename
  WINAMP_SORT_REVERSE            = 40213; // reverses play list
  WINAMP_SORT_RANDOMIZE          = 40212; // randomizes play list


{ IDs 42000 to 45000 are reserved for gen_ff
  IDs from 45000 to 57000 are reserved for library }