#include <sstream>
#include <string>

#pragma hdrstop

// problem with definition of __try - this gets round out with no problems
#define __try try


#include "winampinterface.h"    // header file generated by MIDL compiler

#include "TestRPCServer.h"

// winamp interface
#include "waint.h"

//RPC errors
# include "RPCErrors.h"

#include "WinampTestServer.h"

// this code is only used in the out of process test process
WinampRemote::Server::WinampTestServer localWinamp;

static void inline MainMessage(const char * msgString);
static void inline MainStatus(const char * msgString);


string queryLogFormat(char * strSender, long command, long data)
{

	stringstream sstr;
	sstr.str() = strSender;
	sstr << " sent  - query : " << WinampCommandDesc(command) << " - data : " << data;
	return sstr.str();

}

string commandLogFormat(char * strSender, long command, char * strParam = NULL)
{
	  stringstream sstr;
	  sstr.str() = (char *) strSender;
	  sstr << " sent  - command : " << WinampCommandDesc(command) << " - parameter : " << strParam;
	  return sstr.str();
}


/* __RPC_FAR is literally nothing, but is left in for consistency
- none of the MIDL generated code should need direct modification*/

void WAMessageProc(
    /* [string][in] */ unsigned char __RPC_FAR *pszString)
{

  std::string str = (char *) pszString;
  str += " sent hello";
  MainMessage(str.c_str());

}


void WAExecuteMessage(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [in] */ long command)
{

  MainMessage( commandLogFormat(pszString, command).c_str());

  localWinamp.ExecuteCommand( static_cast<WinampCommand>(command) );

}


void WAExecuteMessageString(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [string][in] */ unsigned char __RPC_FAR *pszParam,
    /* [in] */ long command)
{

	MainMessage( commandLogFormat(pszString, command, pszParam).c_str());

	// TODO: eliminate the cast
	localWinamp.ExecuteStringCommand((const char *) pszParam, static_cast<WinampCommand>(command) );


}

long WAIntegerResult(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [in] */ long command,
    /* [in] */ long data)
{

	MainMessage( queryLogFormat(pszString, command, data).c_str());

	return localWinamp.QueryInt( (WinampCommand) command, data);

}

long WAStringResult( 
    /* [string][out][in] */ unsigned char __RPC_FAR pszString[ 260 ],
    /* [in] */ long command,
    /* [in] */ long data)
{

  MainMessage( queryLogFormat(pszString, command, data).c_str());

  std::string str  = localWinamp.QueryString( static_cast<WinampCommand>(command), data).c_str();

  strcpy((char *) pszString, str.c_str());

  // TODO: this obviously achieves nothing
  return 0;

}

// new functions

void WASetStringList(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [in][size_is] */ byte __RPC_FAR Buffer[  ],
    /* [in] */ unsigned long BufferLength,
    /* [in] */ long command)
{

	// TODO: implement logging
	stringstream sstr;
	sstr.str() = (char *) Buffer;
	string line;
	while (std::getline(sstr, line))
	{
		localWinamp.ExecuteStringCommand(line.c_str(), static_cast<WinampCommand>(command));
	}


	MainStatus("listening...");

}


inline static void populateBuffer(BUFFER * pBuffer, std::string& buffer)
{

	pBuffer->BufferLength = 0;
	int strlen = buffer.size();
	// TODO check this results in the RPC RT returning the memory
	pBuffer->Buffer = (byte *) MIDL_user_allocate (strlen +1);
	if (pBuffer->Buffer)
	{
		pBuffer->BufferLength = strlen + 1;
		memcpy(pBuffer->Buffer, buffer.c_str(), pBuffer->BufferLength);
	}

}

void WAGetStringList(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [out] */ BUFFER __RPC_FAR *pBuffer,
    /* [in] */ long command)
{


	std::stringstream list;
	for (int i = 0 ; i < 20; i++ )
	{
		if (i)
			list << std::endl;
		list << "string #" << i;
	}

	populateBuffer(pBuffer, list.str());
  // TODO: no logging at all here
	MainStatus("listening...");

}


void WAGetStringDataList(
    /* [string][in] */ unsigned char __RPC_FAR *pszString,
    /* [out] */ BUFFER __RPC_FAR *pBuffer,
    /* [in] */ long stringcommand,
    /* [in] */ long datacommand,
    /* [in] */ long datadata)
{

	std::stringstream list;
	for (int i = 0 ; i < 20; i++ )
	{
		if (i)
			list << std::endl;
		list << "string #" << i << std::endl;
		list << "value #" << i;
	}

	populateBuffer(pBuffer, list.str());
	MainStatus("listening...");

}


void WAShutdown(void)
{
    RpcMgmtStopServerListening(NULL);
    RpcServerUnregisterIf(NULL, NULL, FALSE);
    MainStatus("not listening");
    MainMessage("asked to close");
}


ICallObserver* CallObserver = NULL;
static TTestRPCServer::StubCallObserver sco;

void TTestRPCServer::resetStubObserver()
{
	// set the observer to the stub
	if (CallObserver)
		CallObserver = &sco;

}

void TTestRPCServer::Execute(ICallObserver& callObserver)
{

	std::string str;
    RPC_STATUS status;
    unsigned char * protocol_seq_np = (unsigned char *) "ncacn_np";
//    unsigned char * protocol_seq_ip_tcp = "ncacn_ip_tcp";

	// set the observer to the stub
	CallObserver = &callObserver;

    CallObserver->notifyStatus("initialising...");

    str = "winamp version : test";

    CallObserver->notifyMessage(str.c_str());

    // should check status codes here for previously registered interfaces
    // need a property of the appropriate type for the endpoint
    status = RpcServerUseProtseqEp(protocol_seq_np,
                                   20,
                                   (unsigned char *) "\\pipe\\winampremote", NULL);

    if (status == RPC_S_OK){
      status = RpcServerRegisterIf(winamp_v1_0_s_ifspec, NULL, NULL);
      if (status == RPC_S_OK){
    	  CallObserver->notifyMessage("listening...");
        status = RpcServerListen(1, 20, FALSE);
        if (status != RPC_S_OK){
        	CallObserver->notifyMessage("error in listening");
        	CallObserver->notifyMessage(RPCError(status));
          }
        }
    else{
    	CallObserver->notifyMessage("failed to register interface");
    	CallObserver->notifyMessage(RPCError(status));
    	CallObserver->notifyStatus("initialise failed");
      }
    }
  else{
	  CallObserver->notifyMessage("failed to create protocol sequence");
	  CallObserver->notifyMessage(RPCError(status));
	  CallObserver->notifyStatus("initialise failed");
  }

  // reset the observer
  resetStubObserver();

}

static void inline MainMessage(const char * msgString)
{
  CallObserver->notifyMessage(msgString);
}

static void inline MainStatus(const char * msgString)
{
  CallObserver->notifyStatus(msgString);
}


// TODO these are generating an annotation warning in VS2012
/* required user alloc / free function pair */
#pragma warning(suppress: 28251)
void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

#pragma warning(suppress: 28251)
void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    free(ptr);
}

 
