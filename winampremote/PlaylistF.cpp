// winamp remote control suite ©Patrick Michael Martin 2000
//
// PlayListF.cpp
//
// form displaying and allowing editing of playlist
//

#include <vcl.h>
#pragma hdrstop

#include "PlaylistF.h"
#include "waint.h"
#include "MainF.h"
#include "SplashF.h"
#include "RPCFuncsU.h"

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"

// turn off warnings
#include "winampinterface.h"    // header file generated by MIDL compiler


TfrmPlaylist *frmPlaylist;
//---------------------------------------------------------------------------
__fastcall TfrmPlaylist::TfrmPlaylist(TComponent* Owner)
    : TForm(Owner)
{
}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::lstSongsRefresh(TObject *Sender)
{
  char title[RET_STR_SIZE];
  char saveident[RET_STR_SIZE];

  try
  {
    try
    {
      Screen->Cursor = crHourGlass;
      frmMain->sbMain->Panels->Items[0]->Text = "querying server";
      frmMain->sbMain->Refresh();
      lstSongs->Items->BeginUpdate();
      lastlength = IntegerResult(IdentChars, IPC_GETLISTLENGTH, 0);
      lastindex = currentpos;
      currentpos = IntegerResult(IdentChars, IPC_GETLISTPOS, 0);

      // if got this far without exception, so much the better
      strcpy(saveident, IdentChars);

      lstSongs->Items->Clear();
      for (int i = 0 ; i < lastlength ; i++)
      {
        strcpy(title, saveident);
        StringResult(title, IPC_GETPLAYLISTTITLE, i);
        lstSongs->Items->Add((AnsiString(i + 1) + ". " + title));

      // pretty stuff
        if (frmSplash->Visible)
        {
          AnsiString Msg = "getting playlist " + AnsiString(100 * i / lastlength) + "%";
          if (Msg != frmSplash->lblMessage->Caption)
          {
            frmSplash->lblMessage->Caption = Msg;
            frmSplash->lblMessage->Refresh();
          }
        }
      }

      /* keep the forms up to date*/
      if (!frmSplash->Visible){
        frmMain->MainTimer(this);
        }

      }
    catch( ERPCException &E){
      lstSongs->Items->Text = "<list unobtainable>";
    }


  }
  __finally
  {
    Screen->Cursor = crDefault;
    frmMain->sbMain->Panels->Items[0]->Text = "idle";
    lstSongs->Items->EndUpdate();
  }

}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::lstSongsDblClick(TObject *Sender)
{
  IntegerResult(IdentChars, IPC_SETPLAYLISTPOS, lstSongs->ItemIndex);
  ExecuteMessage(IdentChars, WINAMP_PLAYENTRY);

}
//---------------------------------------------------------------------------


void __fastcall TfrmPlaylist::mnuSortClick(TObject *Sender)
{
// these *STILL* don't bleeding work!
  if (Sender == mnuSort)
  {
    IntegerResult(IdentChars, IDC_SORT_FILETITLE, 0);
  }
  if (Sender == mnuSortFile)
  {
    IntegerResult(IdentChars, IDC_SORT_FILENAME, 0);
  }
  if (Sender == mnuSortFileEntire)
  {
    IntegerResult(IdentChars, IDC_SORT_ENTIREFILENAME, 0);
  }

  lstSongsRefresh(this);
}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::FormCreate(TObject *Sender)
{

  lstSongs->ItemHeight = this->Canvas->TextHeight('W');
  lstSongsRefresh(this);

}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::DeleteSelected(void)
{
int i;

char filename[RET_STR_SIZE];
char saveident[RET_STR_SIZE];

  TStringList * StringList = new TStringList;
  try
  {
  /* rather wasteful, as we have to get all the undeleted items and resend them to winamp*/

  int playingpos = -1;

    // cache this
  strcpy(saveident, IdentChars);

    for (i = 0 ; i < lstSongs->Items->Count; i++)
    {
      if (!lstSongs->Selected[i]){
        strcpy(filename, saveident);
        StringResult(filename, IPC_GETPLAYLISTFILE, i);
        StringList->Add(filename);

        if (i == currentpos){
          playingpos = StringList->Count - 1;
          }
        }
      } // for


    // delete
    IntegerResult(IdentChars, IPC_DELETE, 0);

    AddFiles(StringList);
  // reset position

  IntegerResult(IdentChars, IPC_SETPLAYLISTPOS, playingpos);

  lstSongsRefresh(this);
  }
  __finally
  {
    delete StringList;
  }

}

//---------------------------------------------------------------------------


void __fastcall TfrmPlaylist::lstSongsDrawItem(TWinControl *Control,
      int Index, TRect &Rect, TOwnerDrawState State)
{
  int Offset = 4;
  TCanvas *pCanvas = ((TListBox *)Control)->Canvas;
  pCanvas->FillRect(Rect);

  if (Index == currentpos)
  {
    pCanvas->Font->Color = clRed;
  }
  pCanvas->TextOut(Rect.Left + Offset, Rect.Top, ((TListBox *)Control)->Items->Strings[Index]);
  pCanvas->Font->Color = clWindowText;

}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::DropFiles(TMessage& Msg)
{
  char CFileName[MAX_PATH];
  int len, i;
  TStringList * Files = new TStringList;
  void * hDrop = (void *) Msg.WParam;
  int NewPos;

  TPoint DropPoint;

  int DropIndex;
  DragQueryPoint(hDrop, &DropPoint);

  // this returns -1 if there was a hit item
  DropIndex = lstSongs->ItemAtPos(DropPoint, true);

  // get the top of the list
  if (DropIndex > -1)
    GetFilenames(0, DropIndex, Files);
  else
    GetFilenames(0, lstSongs->Items->Count, Files);

  try
  {
    len = DragQueryFile((void *) hDrop, 0xFFFFFFFF, NULL, 0);
    for (i = 0 ; i < len ; i++){
      if (DragQueryFile((void *) hDrop, i, CFileName, MAX_PATH) > 0){
        Files->Add(CFileName);
        }
      }

  // get the rest of the list;
  if (DropIndex > -1)
    GetFilenames(DropIndex, lstSongs->Items->Count, Files);

    // delete
    IntegerResult(IdentChars, IPC_DELETE, 0);

    AddFiles(Files);
  // reset position here

  NewPos = Files->IndexOfObject((TObject *) true);
  IntegerResult(IdentChars, IPC_SETPLAYLISTPOS, NewPos);


    lstSongsRefresh(this);

    }
  __finally
  {
    DragFinish((void *) Msg.WParam);
    delete Files;
  }

}

//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::AddFiles(TStringList * Files)
{
  for (int i = 0 ; i < Files->Count ; i++)
  {
    ExecuteStringMessage(IdentChars, Files->Strings[i].c_str(), IPC_PLAYFILE);
  }
}

//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::SongIndexUpdate(TObject *Sender)
{

  char title[RET_STR_SIZE];
  // needed to ensure we can see the currently playing track
  try
  {
    lstSongs->Items->BeginUpdate();
     strcpy(title, IdentChars);
     // update the current title, at least
     StringResult(title, IPC_GETPLAYLISTTITLE, currentpos);

     try
     {
       bool Selected = lstSongs->Selected[currentpos];
       lstSongs->Items->Strings[currentpos] = (AnsiString(currentpos + 1) + ". " + title);
       lstSongs->Selected[currentpos] =  Selected;
     }
     catch (EStringListError &exception)
     {
       lstSongsRefresh(this);
     }

    /*much neater...*/
    lstSongs->TopIndex = currentpos - 2;
    lstSongs->Refresh();
  }
  __finally
  {
    lstSongs->Items->EndUpdate();
  }
}

//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::FormClose(TObject *Sender,
      TCloseAction &Action)
{
  frmMain->ViewPlaylist->Execute();
}
//---------------------------------------------------------------------------


void __fastcall TfrmPlaylist::GetFilenames(int Start, int Stop, TStringList * StringList)
{
int i;

char filename[RET_STR_SIZE];
char saveident[RET_STR_SIZE];

  // cache this
  strcpy(saveident, IdentChars);

  for (i = Start ; i < Stop; i++)
  {
    strcpy(filename, saveident);
    StringResult(filename, IPC_GETPLAYLISTFILE, i);
    StringList->AddObject(filename, (TObject*) (i == currentpos));
  } // for

}


//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::lstSongsDragOver(TObject *Sender,
      TObject *Source, int X, int Y, TDragState State, bool &Accept)
{
  Accept = true;
}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::lstSongsDragDrop(TObject *Sender,
      TObject *Source, int X, int Y)
{
int i;

char filename[RET_STR_SIZE];
char saveident[RET_STR_SIZE];
bool CurrentSong;
int NewPos;

  // want to know if exceed the list length
  int DropIndex = lstSongs->ItemAtPos(TPoint(X, Y), false);


  TStringList * TopList = new TStringList;
  TStringList * MiddleList = new TStringList;
  TStringList * BottomList = new TStringList;
  try
  {
  /* rather wasteful, as we have to get all the undeleted items and resend them to winamp*/

    // cache this
  strcpy(saveident, IdentChars);

    for (i = 0 ; i < lstSongs->Items->Count; i++)
    {
      strcpy(filename, saveident);
      StringResult(filename, IPC_GETPLAYLISTFILE, i);
      CurrentSong = i == currentpos;

      if (lstSongs->Selected[i])
      {
        MiddleList->AddObject(filename, (TObject *) CurrentSong);
      }
      else if (i < DropIndex)
      {
        TopList->AddObject(filename, (TObject *) CurrentSong);
      }
      else
      {
        BottomList->AddObject(filename, (TObject *) CurrentSong);
      }
    } // for

    // delete
    IntegerResult(IdentChars, IPC_DELETE, 0);

    // rebuild list
    TopList->AddStrings(MiddleList);
    TopList->AddStrings(BottomList);
  // reset position

  AddFiles(TopList);

  NewPos = TopList->IndexOfObject((TObject *) true);
  IntegerResult(IdentChars, IPC_SETPLAYLISTPOS, NewPos);

  lstSongsRefresh(this);
  }
  __finally
  {
    delete BottomList;
    delete MiddleList;
    delete TopList;
  }
}
//---------------------------------------------------------------------------


void __fastcall TfrmPlaylist::FormStartDock(TObject *Sender,
      TDragDockObject *&DragObject)
{
  frmMain->StartDock(Sender, DragObject);
        
}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::FormShow(TObject *Sender)
{
  DragAcceptFiles(lstSongs->Handle, true);
  
}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::FormEndDock(TObject *Sender, TObject *Target,
      int X, int Y)
{
  frmMain->EndDock(Sender, Target, X, Y);
}
//---------------------------------------------------------------------------


void __fastcall TfrmPlaylist::lstSongsMouseMove(TObject *Sender,
      TShiftState Shift, int X, int Y)
{

  int Index = lstSongs->ItemAtPos(TPoint(X, Y), true);

  if (Index > -1)
  {
    lstSongs->Hint = lstSongs->Items->Strings[Index];
  }
  else
  {
    lstSongs->Hint = "Playlist view -drag files to the desired location";
  }

}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::mnuPlayClick(TObject *Sender)
{

  if (BelowIndex > -1)
  {
    lstSongs->ItemIndex = BelowIndex;
    lstSongsDblClick(this);
  }



}
//---------------------------------------------------------------------------


void __fastcall TfrmPlaylist::pmnuSongsPopup(TObject *Sender)
{

  BelowIndex = lstSongs->ItemAtPos(lstSongs->ScreenToClient(Mouse->CursorPos), true);
  mnuPlay->Enabled = (BelowIndex > -1);
  if (BelowIndex > -1)
    mnuPlay->Caption = lstSongs->Items->Strings[BelowIndex];
  else
    mnuPlay->Caption = "Play";


}
//---------------------------------------------------------------------------

void __fastcall TfrmPlaylist::lstSongsKeyDown(TObject *Sender, WORD &Key,
      TShiftState Shift)
{

  switch (Key)
  {
    case VK_DELETE:
      DeleteSelected(); break;
    case 13 :
      lstSongsDblClick(this);
  }

}
//---------------------------------------------------------------------------

